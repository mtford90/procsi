import { describe, it, expect, beforeEach, afterEach } from "vitest";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import { generatePythonOverrideScript, writePythonOverride } from "./python.js";

describe("generatePythonOverrideScript", () => {
  it("contains httplib2 CA_CERTS patch", () => {
    const script = generatePythonOverrideScript("/path/to/ca.pem");
    expect(script).toContain("import httplib2");
    expect(script).toContain("httplib2.CA_CERTS");
  });

  it("contains httplib2 proxy_info patch", () => {
    const script = generatePythonOverrideScript("/path/to/ca.pem");
    expect(script).toContain("httplib2.Http.__init__");
    expect(script).toContain("proxy_info");
    expect(script).toContain("HTTP_PROXY");
  });

  it("wraps patching in try/except", () => {
    const script = generatePythonOverrideScript("/path/to/ca.pem");
    expect(script).toContain("try:");
    expect(script).toContain("except Exception:");
    expect(script).toContain("pass");
  });

  it("includes procsi comment header", () => {
    const script = generatePythonOverrideScript("/path/to/ca.pem");
    expect(script).toContain("# Generated by procsi");
  });

  it("embeds the CA cert path correctly", () => {
    const caCertPath = "/Users/test/.procsi/ca.pem";
    const script = generatePythonOverrideScript(caCertPath);
    expect(script).toContain(`httplib2.CA_CERTS = '${caCertPath}'`);
  });

  it("handles paths with spaces", () => {
    const caCertPath = "/path/with spaces/ca.pem";
    const script = generatePythonOverrideScript(caCertPath);
    expect(script).toContain(`httplib2.CA_CERTS = '/path/with spaces/ca.pem'`);
  });

  it("escapes paths with single quotes", () => {
    const caCertPath = "/path/with'quote/ca.pem";
    const script = generatePythonOverrideScript(caCertPath);
    // Single quote should be escaped as \'
    expect(script).toContain(`httplib2.CA_CERTS = '/path/with\\'quote/ca.pem'`);
  });

  it("escapes paths with backslashes (Windows)", () => {
    const caCertPath = "C:\\Users\\test\\.procsi\\ca.pem";
    const script = generatePythonOverrideScript(caCertPath);
    // Backslashes should be doubled
    expect(script).toContain(`httplib2.CA_CERTS = 'C:\\\\Users\\\\test\\\\.procsi\\\\ca.pem'`);
  });

  it("handles paths with both backslashes and quotes", () => {
    const caCertPath = "C:\\Program Files\\procsi's data\\ca.pem";
    const script = generatePythonOverrideScript(caCertPath);
    expect(script).toContain(
      `httplib2.CA_CERTS = 'C:\\\\Program Files\\\\procsi\\'s data\\\\ca.pem'`
    );
  });
});

describe("writePythonOverride", () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "procsi-python-test-"));
  });

  afterEach(() => {
    // Clean up temp directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("creates sitecustomize.py file on disk", () => {
    const caCertPath = "/path/to/ca.pem";
    const outputDir = path.join(tempDir, "override");

    writePythonOverride(outputDir, caCertPath);

    const scriptPath = path.join(outputDir, "sitecustomize.py");
    expect(fs.existsSync(scriptPath)).toBe(true);
  });

  it("writes correct content to file", () => {
    const caCertPath = "/path/to/ca.pem";
    const outputDir = path.join(tempDir, "override");

    writePythonOverride(outputDir, caCertPath);

    const scriptPath = path.join(outputDir, "sitecustomize.py");
    const content = fs.readFileSync(scriptPath, "utf-8");

    expect(content).toContain("# Generated by procsi");
    expect(content).toContain(`httplib2.CA_CERTS = '${caCertPath}'`);
    expect(content).toContain("import httplib2");
  });

  it("creates parent directories recursively", () => {
    const caCertPath = "/path/to/ca.pem";
    const outputDir = path.join(tempDir, "nested", "deep", "directory");

    writePythonOverride(outputDir, caCertPath);

    const scriptPath = path.join(outputDir, "sitecustomize.py");
    expect(fs.existsSync(scriptPath)).toBe(true);
  });

  it("returns the output directory path", () => {
    const caCertPath = "/path/to/ca.pem";
    const outputDir = path.join(tempDir, "override");

    const result = writePythonOverride(outputDir, caCertPath);

    expect(result).toBe(outputDir);
  });

  it("handles existing directory", () => {
    const caCertPath = "/path/to/ca.pem";
    const outputDir = path.join(tempDir, "override");

    // Create directory first
    fs.mkdirSync(outputDir, { recursive: true });

    // Should not throw
    writePythonOverride(outputDir, caCertPath);

    const scriptPath = path.join(outputDir, "sitecustomize.py");
    expect(fs.existsSync(scriptPath)).toBe(true);
  });

  it("overwrites existing sitecustomize.py", () => {
    const caCertPath1 = "/path/to/ca1.pem";
    const caCertPath2 = "/path/to/ca2.pem";
    const outputDir = path.join(tempDir, "override");

    writePythonOverride(outputDir, caCertPath1);
    writePythonOverride(outputDir, caCertPath2);

    const scriptPath = path.join(outputDir, "sitecustomize.py");
    const content = fs.readFileSync(scriptPath, "utf-8");

    expect(content).toContain(caCertPath2);
    expect(content).not.toContain(caCertPath1);
  });

  it("throws error with descriptive message on write failure", () => {
    const caCertPath = "/path/to/ca.pem";
    // Use an invalid path to trigger write failure
    const invalidDir = "\0invalid";

    expect(() => {
      writePythonOverride(invalidDir, caCertPath);
    }).toThrow(/Failed to write Python override/);
  });
});
