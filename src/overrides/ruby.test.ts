import { afterEach, describe, expect, it } from "vitest";
import * as fs from "node:fs";
import * as path from "node:path";
import * as os from "node:os";
import { generateRubyOverrideScript, writeRubyOverride } from "./ruby.js";

describe("generateRubyOverrideScript", () => {
  it("contains expected OpenSSL monkey-patch", () => {
    const script = generateRubyOverrideScript("/path/to/ca.pem");

    expect(script).toContain("require 'openssl'");
    expect(script).toContain("module OpenSSL");
    expect(script).toContain("module X509");
    expect(script).toContain("class Store");
    expect(script).toContain("alias_method :original_set_default_paths");
    expect(script).toContain("def set_default_paths");
    expect(script).toContain("original_set_default_paths");
    expect(script).toContain("add_file(procsi_ca_path)");
  });

  it("wraps in begin/rescue block", () => {
    const script = generateRubyOverrideScript("/path/to/ca.pem");

    expect(script).toMatch(/^begin\n/m);
    expect(script).toContain("rescue => e");
    expect(script).toContain("end");
  });

  it("includes descriptive comment", () => {
    const script = generateRubyOverrideScript("/path/to/ca.pem");

    expect(script).toContain(
      "# Generated by procsi â€” ensures Ruby trusts the proxy CA certificate"
    );
  });

  it("embeds the CA cert path correctly", () => {
    const caCertPath = "/home/user/.procsi/ca.pem";
    const script = generateRubyOverrideScript(caCertPath);

    expect(script).toContain(`procsi_ca_path = '${caCertPath}'`);
    expect(script).toContain("File.exist?(procsi_ca_path)");
  });

  it("handles paths with special characters", () => {
    const caCertPath = "/path/with spaces/and'quotes/ca.pem";
    const script = generateRubyOverrideScript(caCertPath);

    // Single quotes should be escaped
    expect(script).toContain("procsi_ca_path = '/path/with spaces/and\\'quotes/ca.pem'");
  });

  it("handles paths with backslashes", () => {
    const caCertPath = "C:\\Users\\test\\ca.pem";
    const script = generateRubyOverrideScript(caCertPath);

    // Backslashes should be preserved (Ruby will handle them)
    expect(script).toContain("procsi_ca_path = 'C:\\Users\\test\\ca.pem'");
  });

  it("includes file existence check", () => {
    const script = generateRubyOverrideScript("/path/to/ca.pem");

    expect(script).toContain("if File.exist?(procsi_ca_path)");
  });
});

describe("writeRubyOverride", () => {
  let tempDir: string;

  afterEach(() => {
    if (tempDir && fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  it("creates the file on disk", () => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "procsi-ruby-test-"));
    const caCertPath = "/test/ca.pem";

    const filePath = writeRubyOverride(tempDir, caCertPath);

    expect(fs.existsSync(filePath)).toBe(true);
    const content = fs.readFileSync(filePath, "utf-8");
    expect(content).toContain("procsi_ca_path = '/test/ca.pem'");
  });

  it("creates parent directories", () => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "procsi-ruby-test-"));
    const nestedDir = path.join(tempDir, "nested", "deep", "dir");
    const caCertPath = "/test/ca.pem";

    const filePath = writeRubyOverride(nestedDir, caCertPath);

    expect(fs.existsSync(filePath)).toBe(true);
    expect(fs.existsSync(nestedDir)).toBe(true);
  });

  it("returns the file path", () => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "procsi-ruby-test-"));
    const caCertPath = "/test/ca.pem";

    const filePath = writeRubyOverride(tempDir, caCertPath);

    expect(filePath).toBe(path.join(tempDir, "procsi_intercept.rb"));
    expect(path.isAbsolute(filePath)).toBe(true);
  });

  it("writes valid Ruby script", () => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "procsi-ruby-test-"));
    const caCertPath = "/test/ca.pem";

    const filePath = writeRubyOverride(tempDir, caCertPath);
    const content = fs.readFileSync(filePath, "utf-8");

    expect(content).toContain("begin");
    expect(content).toContain("require 'openssl'");
    expect(content).toContain("rescue => e");
    expect(content).toContain("end");
  });
});
