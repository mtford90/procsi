/**
 * `procsi completions <shell>` â€” generate shell completion scripts.
 *
 * Outputs a completion script that the user sources in their shell config.
 * Generated by walking the Commander program tree.
 */

import { Command } from "commander";

const SUPPORTED_SHELLS = ["zsh", "bash", "fish"];

/**
 * Escape a string for use inside a single-quoted shell string.
 * Replaces ' with '\'' (end quote, escaped quote, start quote).
 */
function escapeForShell(str: string): string {
  return str.replace(/'/g, "'\\''");
}

/**
 * Collect all commands recursively from a Commander program.
 */
interface CommandInfo {
  name: string;
  description: string;
  options: { flags: string; description: string }[];
  subcommands: CommandInfo[];
}

function collectCommands(cmd: Command): CommandInfo[] {
  return cmd.commands.map((sub: Command) => ({
    name: sub.name(),
    description: sub.description(),
    options: sub.options.map((opt) => ({
      flags: opt.long ?? opt.short ?? "",
      description: opt.description,
    })),
    subcommands: collectCommands(sub),
  }));
}

/**
 * Generate a zsh completion script.
 */
function generateZshCompletions(program: Command): string {
  const commands = collectCommands(program);
  const globalOptions = program.options.map(
    (opt) => `'${escapeForShell(opt.long ?? opt.short ?? "")}[${escapeForShell(opt.description)}]'`
  );

  const subcmdCases = commands
    .map((cmd) => {
      const opts = cmd.options
        .map((o) => `'${escapeForShell(o.flags)}[${escapeForShell(o.description)}]'`)
        .join(" \\\n          ");
      const subs = cmd.subcommands
        .map((s) => `'${escapeForShell(s.name)}:${escapeForShell(s.description)}'`)
        .join(" ");
      const subsSection = subs
        ? `\n        local -a ${cmd.name}_subcommands\n        ${cmd.name}_subcommands=(${subs})\n        _describe -t commands '${escapeForShell(cmd.name)} subcommand' ${cmd.name}_subcommands`
        : "";

      return `      ${cmd.name})\n        _arguments ${opts}${subsSection}\n        ;;`;
    })
    .join("\n");

  const cmdList = commands
    .map((c) => `'${escapeForShell(c.name)}:${escapeForShell(c.description)}'`)
    .join(" \\\n    ");

  return `#compdef procsi

# Auto-generated by procsi completions zsh
# Add to your .zshrc: eval "$(procsi completions zsh)"

_procsi() {
  local -a commands
  commands=(
    ${cmdList}
  )

  _arguments -C \\
    ${globalOptions.join(" \\\n    ")} \\
    '1:command:->command' \\
    '*::arg:->args'

  case "$state" in
    command)
      _describe -t commands 'procsi command' commands
      ;;
    args)
      case "$words[1]" in
${subcmdCases}
      esac
      ;;
  esac
}

compdef _procsi procsi
`;
}

/**
 * Generate a bash completion script.
 */
function generateBashCompletions(program: Command): string {
  const commands = collectCommands(program);
  const cmdNames = commands.map((c) => c.name).join(" ");

  const subcmdCases = commands
    .map((cmd) => {
      const opts = cmd.options.map((o) => escapeForShell(o.flags)).join(" ");
      const subs = cmd.subcommands.map((s) => escapeForShell(s.name)).join(" ");
      return `    ${cmd.name})\n      COMPREPLY=($(compgen -W "${opts} ${subs}" -- "$cur"))\n      ;;`;
    })
    .join("\n");

  return `# Auto-generated by procsi completions bash
# Add to your .bashrc: eval "$(procsi completions bash)"

_procsi() {
  local cur prev words cword
  _init_completion || return

  local commands="${cmdNames}"

  if [[ $cword -eq 1 ]]; then
    COMPREPLY=($(compgen -W "$commands" -- "$cur"))
    return
  fi

  case "\${words[1]}" in
${subcmdCases}
  esac
}

complete -F _procsi procsi
`;
}

/**
 * Generate a fish completion script.
 */
function generateFishCompletions(program: Command): string {
  const commands = collectCommands(program);
  const lines: string[] = [
    "# Auto-generated by procsi completions fish",
    "# Add to your config: procsi completions fish | source",
    "",
    "# Disable file completions by default",
    "complete -c procsi -f",
    "",
  ];

  // Top-level commands
  for (const cmd of commands) {
    lines.push(
      `complete -c procsi -n '__fish_use_subcommand' -a '${escapeForShell(cmd.name)}' -d '${escapeForShell(cmd.description)}'`
    );
  }

  lines.push("");

  // Subcommand options
  for (const cmd of commands) {
    for (const opt of cmd.options) {
      const flag = opt.flags.replace(/^--/, "");
      lines.push(
        `complete -c procsi -n '__fish_seen_subcommand_from ${cmd.name}' -l '${escapeForShell(flag)}' -d '${escapeForShell(opt.description)}'`
      );
    }
    for (const sub of cmd.subcommands) {
      lines.push(
        `complete -c procsi -n '__fish_seen_subcommand_from ${cmd.name}' -a '${escapeForShell(sub.name)}' -d '${escapeForShell(sub.description)}'`
      );
    }
  }

  return lines.join("\n") + "\n";
}

export const completionsCommand = new Command("completions")
  .description("Generate shell completion scripts")
  .argument("<shell>", `shell type (${SUPPORTED_SHELLS.join(", ")})`)
  .action((shell: string, _opts: Record<string, unknown>, command: Command) => {
    if (!SUPPORTED_SHELLS.includes(shell)) {
      console.error(`Unsupported shell: "${shell}"`);
      console.error(`Supported shells: ${SUPPORTED_SHELLS.join(", ")}`);
      process.exit(1);
    }

    // Walk up to the root program
    let root: Command = command;
    while (root.parent) {
      root = root.parent;
    }

    if (shell === "zsh") {
      console.log(generateZshCompletions(root));
    } else if (shell === "bash") {
      console.log(generateBashCompletions(root));
    } else if (shell === "fish") {
      console.log(generateFishCompletions(root));
    }
  });
